\documentclass[../main.tex]{subfiles}

\begin{document}
\section{Programowanie funkcyjne - podstawy teoretyczne}
Programowanie funkcyjne jest filozofią i metodyką programowania opierającą się prostym założeniu, iż programy napisane w tym paradygmacie używają tylko i wyłącznie "czystych" funkcji (ang. pure functions) \cite{BOOK:FPinScala} - innymi słowy funkcji, które spełniają dwa warunki: 
\begin{itemize}
\item ich dane wyjściowe zależą tylko i wyłącznie od danych wejściowych,
\item nie posiadają efektów ubocznych.
\end{itemize}
\vspace{3ex}
Funkcja posiada efekty uboczne jeśli robi coś innego niż zwrócenie rezultatu - na przykład: 
\begin{itemize}
    \item modyfikuje zmienną,
    \item modyfikuje stan struktury danych w miejscu,
    \item ustawia pole obiektu,
    \item rzuca wyjątek,
    \item przerywa działanie całego programu,
    \item wypisuje dane na ekran lub do pliku,
    \item wczytuje dane od użytkownika lub z pliku.
\end{itemize}
\vspace{3ex}
To proste z pozoru założenie ma bardzo daleko idące skutki nie tylko w samej architekturze kodu aplikacji, lecz również w tym w jaki sposób patrzy się na programy napisane w paradygmacie funkcyjnym.\newline\newline
Korzystając z "czystych" funkcji zyskujemy na modularności kodu. Funkcje takie są zdecydowanie łatwiejsze do przetestowania, ponownego użycia, wykonania równoległego, uogólnienia, a przede wszystkim do zrozumienia. Dodatkowo są one mniej podatne na nieoczekiwane, błędne działanie z powodu błędu w sztuce programistycznej.\newline\newline
Lecz w jaki sposób programy złożone z funkcji, które nie mogą wykonywać zdefiniowanych powyżej czynności, mogą być jakkolwiek przydatne? 
Otóż programowanie funkcyjne udostępnia specjalne struktury, które pozwalają nam opisać efekty uboczne, jakie chcemy wykonać i tworzyć programy komponując te efekty ze sobą. Pozwala to na tworzenie w całości programów bez efektów ubocznych, które wykonują operacje wejścia/wyjścia, modyfikują dane oraz obsługują błędy.

\subsection{Przykład programu z efektami ubocznymi}
Aby lepiej wyjaśnić na czym polega "czysta" funkcja, autor pozwolił sobie wykorzystać doskonały w jego opinii przykład kodu ilustrujący funkcję która nie jest "czystą" funkcją a następnie jej ewolucję w "czystą" funkcję. Fragment kodu pochodzi z równie doskonałej pozycji z literatury "Functional Programming in Scala" autorstwa panów Paul'a Chiusano oraz Runar'a Bjarnason \cite{BOOK:FPinScala}.

\begin{lstlisting}[caption=Funkcja z efektami ubocznymi. Przykład zaczerpnięty z \cite{BOOK:FPinScala}]
class Cafe { 
  def buyCoffe(cc: CreditCard): Coffee = {
    val cup = new Coffee()
    cc.charge(cup.price)
    cup
  }
}
\end{lstlisting}
Powyższy fragment kodu definiuje funkcje której zadaniem jest obsłużyć zajście kupowania kawy.
Funkcja tworzy nowy obiekt reprezentujący kawę, obciąża przekazaną jako parametr kartę kredytową jego ceną i zwraca stworzoną kawę. Oczywistym efektem ubocznym, który tutaj zachodzi jest obciążenie karty kredytowej. Można śmiało zakładać, że następuje połączenie z serwisem internetowym w celu przeprowadzenia transakcji. Niezwykle ciężko jest przetestować taki fragment kodu, właśnie przez zachodzące przy jego wywołaniu efekty uboczne. Istnieje potrzeba wyabstrahowania nad typem karty kredytowej w celu stworzenia czegoś w rodzaju testowej karty kredytowej, przy użyciu której nie zajdzie faktyczna interakcja z serwisem transakcyjnym. Kolejnym problemem jest to jak ciężko jest wykorzystać wielokrotnie przedstawioną funkcję. Załóżmy, że klient zakupił więcej niż jedną kawę. Wywołanie funkcji w pętli nie jest dobrym pomysłem ze względu na każdorazowe powstanie efektu ubocznego, który w tym wypadku może być na przykład związany z prowizjami za wykonanie transakcji. W jaki sposób możemy zatem poprawić powyższy fragment kodu?

\subsection{Funkcyjne rozwiązanie: usunięcie efektów ubocznych}
Poniższy fragment przedstawia zmodyfikowany fragment kodu z poprzedniego paragrafu.
\begin{lstlisting}[caption=Funkcja bez efektów ubocznych. . Przykład zaczerpnięty z \cite{BOOK:FPinScala}]
class Cafe { 
  def buyCoffe(cc: CreditCard): (Coffee, Charge) = {
    val cup = new Coffee()
    (cup, Charge(cc, cup.price))
  }
}
\end{lstlisting}
Jako przykład funkcyjnego rozwiązania w celu wyeliminowania efektów ubocznych została stworzona konstrukcja reprezentująca zajście obciążenia karty kredytowej. Funkcja zwraca teraz zarówno sam oczekiwany obiekt, jak i obiekt reprezentujący efekt uboczny. Kod jest teraz zdecydowanie łatwiejszy do przetestowania oraz wielokrotnego użycia. Wystarczy że zsumujemy powstałe z zamówień obiekty reprezentujące obciążenie karty, a wykonanie tego efektu oddelegujemy w późniejszy moment wykonania programu.
W celu zsumowania wartości zamówień poprzez ponowne wykorzystanie przedstawionej funkcji autor pracy napisał następujący fragment kodu bazując nadal na przykładzie z książki \cite{BOOK:FPinScala}.

\begin{lstlisting}[caption=Fragment kodu ponownie wykorzystujący funkcję przerestrukturyzowaną w zgodzie z paradygmatem funkcyjnym. Na podstawie \cite{BOOK:FPinScala}]
case class CreditCard(id: String)

case class Coffee(name: String, price: Int)

case class Charge(cc: CreditCard, amount: Int) {

  def combine(other: Charge): Charge = {
    if (cc.id == other.cc.id) {
      Charge(cc, amount + other.amount)
    } else {
      this
    }
  }
}

object Main extends App {

  def buyCoffee(cc: CreditCard): (Coffee, Charge) = {
    val coffee = Coffee("Latte", 12)
    (coffee, Charge(cc, coffee.price))
  }

  def buyManyCoffees(cc: CreditCard, n: Int): (List[Coffee], Charge) = {
    val purchases: List[(Coffee, Charge)] = List.fill(n)(buyCoffee(cc))
    val (coffees, charges) = purchases.unzip
    (coffees, charges.reduce(_ combine _))
  }

  def calculateChargesForAllCards(charges: List[Charge]): Map[String, Int] = {
    charges.groupBy(_.cc) map { cardWithCharges: (CreditCard, List[Charge]) =>
      val (creditCard, chargesForCard) = cardWithCharges
      val amountForCard: Int = chargesForCard.foldLeft(0)(_ + _.amount)
      (creditCard.id, amountForCard)
    }
  }

  val creditCard_1 = CreditCard("creditCard_1")
  val creditCard_2 = CreditCard("creditCard_2")
  val coffeesForCC_1 = buyManyCoffees(creditCard_1, 3)
  val coffeesForCC_2 = buyManyCoffees(creditCard_2, 8)

  println(calculateChargesForAllCards(List(coffeesForCC_1._2, coffeesForCC_2._2)))
  
  // wynikiem wykonania powyzszego programu jest:
  // Map(creditCard_1 -> 36, creditCard_2 -> 96)
}

\end{lstlisting}



\subsection{Referencyjna transparentność (ang. Referential Transparency)}
Na początku tego rozdziału autor definiując pojęcie programowania funkcyjnego wspomniał, iż polega ono na korzystaniu z "czystych" funkcji. Wymieniając zalety korzystania właśnie z takich funkcji dopuścił się stwierdzenia o ułatwionym zadaniu zrozumienia tego szczególnego rodzaju konstrukcji. Wszystkie wymienione atuty można sprowadzić do stwierdzenia, że używanie czystych funkcji daje nam własność, która nazywa się "referencyjna transparentność" (ang. referential transparency).
Zdefiniowana jest ona w następujący sposób:
\begin{center}
\textit{Wyrażenie e jest "referencyjnie transparentne" w stosunku do programu p, jeżeli każde wystąpienie e w p może zostać zastąpione przez rezultat wykonania e bez zmiany w wyniku p.} \cite{BOOK:FPinScala} 
\end{center}
Aby lepiej zobrazować tą własność autor pozwolił sobie posłużyć się przykładem.
Niech program p będzie zdefiniowany w następujący sposób:
\begin{lstlisting}[caption=Przykładowy program w języku Scala.]
val x: Int = ???

val y: Int = x * x
\end{lstlisting}
Czy program ten jest referencyjnie transparentny? Odpowiedź brzmi: "To zależy". A dokładniej zależy to od wartości zmiennej \textit{x}. W przypadku pierwszym:
\begin{lstlisting}[caption=Referencyjnie transparentny program.]
val x: Int = 2

val y: Int = x * x
\end{lstlisting}
program będzie referencyjnie transparentny - każde wystąpienie zmiennej x możemy z powodzeniem zastąpić jej wartością a wynik programu pozostanie bez zmian.
Natomiast w drugim przypadku:
\begin{lstlisting}[caption=Program który nie jest referencyjnie transparentny.]
val x: Int = {
  println("Hello, world")
  2
}

val y: Int = x * x
\end{lstlisting}
program nie jest już referencyjnie transparentny z uwagi na to, iż zaobserwowany wynik z jego wykonania będzie inny w zależności od tego, czy do zmiennej \textit{x} zostanie przypisana wartość wyrażenia, czy też każde wystąpienie zmiennej \textit{x} zastąpimy wspomnianym wyrażeniem.\newline
Autor chciałby posłużyć się jeszcze innym przykładem w celu zobrazowania nieco mniej trywialnego przykładu, który jego zdaniem doskonale wyjaśnia referencyjną transparentność oraz to w jaki sposób funkcyjne struktury spełniają jej założenia, a także dlaczego znana z biblioteki standardowej konstrukcja \textit{Future} łamie jej zasady. \textit{Future} jest strukturą reprezentującą wynik przyszłych obliczeń, które wykonywane są w osobnym wątku, nie blokując przy tym głównego wątku.

Aby nieco ułatwić zrozumienie tego przykładu zakładamy, że po każdym wyzerowaniu ziarna generator liczb pseudolosowych generuje kolejne liczby pierwsze tj. 1, 3, 5, 7, 13, 17, 19, 23 itd.

\begin{lstlisting}
val r = scala.util.Random
r.setSeed(0)

val a: Int = r.nextInt // generuje wartosc 1
val b: Int = a + 1     // 1 + 1

val c: Int = a + b // 1 + 1 + 1
val d: Int = r.nextInt + (r.nextInt + 1) // 3 + 5 + 1



val a: Future[Int] = Future(r.nextInt) // generuje przyszla wartosc 1

val b: Future[Int] = a.map(_ + 1) // 1 + 1

val c: Future[Int] = for { 
    a0 <- a
    b0 <- b 
  } yield a0 + b0 // 1 + 1 + 1

val d: Future[Int] = for {  
    a1 <- Future(r.nextInt)
    a2 <- Future(r.nextInt + 1) 
  } yield a1 + a2 // 3 + 5 + 1

\end{lstlisting}

Łatwo stwierdzić, poprzez zamienienie wyrażeń ich implementacją, że dwa powyższe fragmenty kodu nie są referencyjnie transparentne. Dzieje się to ze względu na to, że \textit{Future} wykonywany jest natychmiast po utworzeniu oraz zapamiętuje on swoją wartość.\newline
Natomiast prześledźmy w jaki sposób zachowuje się w analogicznym przykładzie struktura IO. Pochodzi ona z biblioteki Cats \cite{WEBSITE:CatsDataTypes}, a dokładniej Cats Effects. Reprezentuje operacje wyjścia/wejścia w funkcyjny sposób. W tym przykładzie generowanie kolejnej liczby pseudolosowej uważa się za mającą efekt uboczny operację wejścia. Efektem ubocznym jest zmiana ziarna generatora liczb pseudolosowych.

\begin{lstlisting}
val r = scala.util.Random

val a: Int = r.nextInt  // generuje wartosc 1
val b: Int = a + 1      // 1 + 1

val c: Int = a + b      // 1 + 1 + 1
val d: Int = r.nextInt + (r.nextInt + 1) // 3 + 5 + 1



val a: IO[Int] = IO(r.nextInt) 
// generuje wartosc 1 kiedy zostanie wykonane

val b: IO[Int] = a.map(_ + 1) 
// generuje 3 + 1 kiedy zostanie wykonane

val c: IO[Int] = (a, b).mapN(_ + _) 
// 5 + 7 + 1

val d: IO[Int] = (IO(r.nextInt), IO(r.nextInt + 1)).mapN(_ + _) 
// 13 + 17 + 1

\end{lstlisting}
W tym przypadku program okazał się referencyjnie transparentny. Jest tak dzięki temu, gdyż konstrukcja \textit{IO} stanowi jedynie opis wykonania programu - przepis na program. Samo wykonanie kodu z ostatniej części powyższego przykładu nie skutkuje obliczeniem żadnej wartości. Dopiero wywołanie na zmiennej typu \textit{IO} metody \textit{unsafeRunSync()} będzie skutkowało obliczeniem wartości wyrażenia. Na pytanie dlaczego tak się dzieje autor ma nadzieję odpowiedzieć czytelnikowi w następnych rozdziałach.


Do czego zatem możemy wykorzystać własność referencyjnej transparentności?

\subsection{Lokalne rozumowanie (ang. Local reasoning)}
Jest to własność, która pozwala się skupić na rozumowaniu części programu (np. funkcji) bez konieczności rozważania zewnętrznego kontekstu w jakim program jest wykonywany, bądź też stanu w jakim program aktualnie się znajduje. Cały program składa się zatem z kompozycji mniejszych części, które też są same w sobie programami. Szukając przyczyny defektu w takim systemie łatwiej jest znaleźć błąd w implementacji sprawdzając poprawność każdego z mniejszych programów, który składa się na większą całość. Dzięki temu nie ma potrzeby pamiętania cały czas i zwracania uwagi na możliwe stany i scenariusze, które nie dotyczą stricte części sprawdzanego programu. W dużym, złożonym systemie możliwość opierania się o tą własność jest nieoceniona.

\subsection{Efekty uboczne, a efekty}
We wcześniejszym paragrafie autor zanegował przydatność programów niemożnych do stworzenia efektów ubocznych w otaczającym świecie. Jaka byłaby przydatność z programu który nie może w żaden sposób komunikować się czy to z użytkownikiem czy z siecią internetową? Nie można by było nawet stwierdzić czy program faktycznie się wykonał czy też nie, nie mówiąc już nawet o czerpaniu jakiejkolwiek wartości z wykonania takiego programu.\vspace{3ex}
Programowanie funkcyjne nie polega na wyeliminowaniu efektów ubocznych, lecz na odsunięciu ich jak najpóźniej jest to możliwe. Jest to tak zwane wykonanie efektów ubocznych "na końcu świata" (ang. "at the end of the world") \cite{WEBSITE:Fabio} i określa to najczęściej ostatnią instrukcję w programie. W kodzie programista pracuje natomiast z funkcyjnymi strukturami, które opierają się na teorii kategorii\footnote{teoria matematyczna, mająca swoje pojęcia pierwotne, aksjomaty, definicje, twierdzenia, dowody i bardzo ważne zastosowania w wielu innych działach matematyki - na podstawie Wikipedii - autor zastrzega sobie prawo do nie wnikania w szczegóły tego zagadnienia ponieważ nie jest to tematem niniejszej pracy}. Opisują one dany efekt ze świata zewnętrznego na przykład:
\begin{itemize}
    \item operację wejścia/wyjścia,
    \item możliwy brak wartości,
    \item wypisanie wartości w celu śledzenia przebiegu programu,
    \item specyficzny błąd lub oczekiwany wynik wykonania programu,
    \item skumulowane błędy lub oczekiwany wynik wykonania programu,
    \item stan, wraz z możliwością jego modyfikacji.
\end{itemize}
Dla każdego wymienionego powyżej efektu ubocznego istnieje funkcyjna struktura.
Dzięki temu kod pozostaje niezanieczyszczony występowaniem efektów ubocznych, co skutkuje większą kontrolą nad możliwymi wynikami działania programu oraz jego zachowaniem. Konstrukcje te ponadto ze względu na właściwości opisane w dalszej części niniejszej pracy umożliwiają zbudowanie rozbudowanego systemu w całkowicie funkcyjnym paradygmacie. Z tego właśnie powodu ostatni program z rozdziału pt. "Referencyjna transparentność (ang. Referential Transparency)" nie miał zauważalnego rezultatu bez wywołania na którejś ze zmiennych typu \textit{IO} metody \textit{unsafeRunSync()}. To właśnie ta metoda powinna być ostatnią instrukcją w programie, po której nasz program ma widoczne skutki w świecie zewnętrznym. 

\subsection{Testy}
Opisywanie efektów ze świata zewnętrznego za pomocą funkcyjnych konstrukcji daje nam też możliwość łatwiejszego testowania kodu. Programista nie musi sprawdzać czy efekt uboczny zaszedł w świecie rzeczywistym ponieważ jego zadaniem jest tylko i wyłącznie stworzenie kodu dającego oczekiwane rezultaty dla odpowiednich danych wejściowych. Natomiast poprawne wykonanie tychże efektów, tak aby miały odzwierciedlenie w rzeczywistości leży w gestii twórców bibliotek lub języka udostępniających konstrukcje reprezentujące dany efekt uboczny. Co jest naturalnym następstwem powyższego stwierdzenia, nie są potrzebne specjalistyczne narzędzia służące do tworzenia testowych obiektów (na przykład testowych baz danych).

\end{document}
